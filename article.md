#..и транслятор SQL из Oracle в Postgres (а то название какое-то слишком длинное получается)

Здравствуй, бро.

Это ещё одна статья про ещё-одно-средство-распознавания-языков (ANother Tool for Language Recognition, ANTLR) версии 4. Мы рассмотрим механизмы создания парсеров и создадим небольшой транслятор иерархических запросов Oracle в PostgreSQL. 

<cut>
  
## Про задачу распознавания языков


## Немного сведений про ANTLR

### Visitor vs Listener

Если внимательно посмотреть на грамматику (которая располагается в файле PlSqlParser.g4), то в районе 3300-ой строки можно заметить правило `query_block`, которое отвечает за распознавание SELECT выражений:

```
query_block
    : SELECT (DISTINCT | UNIQUE | ALL)? selected_list
      into_clause? from_clause where_clause? hierarchical_query_clause? group_by_clause? model_clause?
    ;
```

Здесь мы видим ключевые токены `SELECT`, `DISTINCT`, `UNIQUE`, `ALL`, а также вложенные подправила `selected_list`, `into_clause`, `from_clause` и тому подобные. В конце некоторых правил указан знак вопроса (например, `into_clause?`) - это означает, что появление соответствующего ему выражения в необязательно (действительно, не в каждом валидном `SELECT`-запросе должно присутствовать `INTO` выражение).

Некоторые правила (терминальные ноды наподобие `DISTINCT`, `UNIQUE`, `ALL` тоже являются "вырожденными" правилами) могут быть разделены знаком `|`, что означает возможность применения одного из указанных подправил. Это такое своеобразное "ИЛИ".

Давайте теперь посмотрим на подправило `hierarchical_query_clause`. Согласно нашей грамматике, оно выглядит так:

```
hierarchical_query_clause
    : CONNECT BY NOCYCLE? condition start_part?
    | start_part CONNECT BY NOCYCLE? condition
    ;
```

Здесь самое время отметить, что мы в этой статье сосредотачиваемся на трансляции иерархических запросов на структурном уровне и не погружаемся в особенности реализации в PL\SQL, например, условий в `WHERE` части запроса, которые могут быть несовместимыми между Oracle и PostgreSQL. Однако, если углубляться в эту кроличью нору, то принцип работы с другими правилами из грамматики

Для начала добавим операции

## Вопросы

Забегая вперед, хочется ответить на те вопросы, которые могут возни

* **Почему python?** Действительно, решение использовать antlr runtime на python является очень спорным для грамматик таких крупных языков, как PL/SQL. Автор участвовал в проекте БАРС Груп, целью которого было создание автоматического конвертера для одной крупной системы с Oracle на PostgreSQL (более 30.000 конвертируемых объектов: представления, триггеры, функции, процедуры, пакеты и т.п.). Мы делали такой конвертер c использованием runtime на Java. Но в данном случае, как-то захотелось попробовать проделать то же самое, только для python.

**Разве данный код является достаточным для того, чтобы конвертировать иерархические запросы в реальных условиях?** Вот прям код, который содержится в репозитории статьи, конечно, не является полным. В реальных условиях, иерархические запросы могут быть написаны на PL/SQL намного более сложным образом. Однако, если привести код, который обрабатывает практически все варианты написания иерархических запросов, то автор, как миниумум, запутает читателя ненужными деталями (всё-таки, эта статья задумывалась как ознакомительная с возможностями ANTLR4), и скорее всего, нарушит какие-то соглашения про коммерческую тайну.

## Полезные материалы

Про CaseInsensitiveLexing
https://github.com/antlr/antlr4/blob/master/doc/case-insensitive-lexing.md

</cut>
